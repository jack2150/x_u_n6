<?
##
# The code that deals with calculating elapsed time, time remaining
# and upload speed were contributed by Orest Kinasevych
##

# status codes = 0-uploading, 1-started, 2- complete

include 'config.php';
include 'includes/upload.class.php';

# initiate the class
$uploader = new uploader($server_id);

# sanitize input
$iMode     = intval($_GET['iMode']);
$sessionid = preg_replace('/[^A-Za-z0-9]/','',$_GET['sessionid']);
$iTotal    = intval($_GET['iTotal']);
$iRead     = intval($_GET['iRead']);
$status    = intval($_GET['iStatus']);
$lastRead  = $iRead;

$uploader->temp_dir = $iMode==1 ? $cgi_temp_dir : $php_temp_dir;
$uploader->upload_session = $sessionid;
$uploader->upload_mode = $iMode;

# system used file
$data_file    = $uploader->temp_dir .'/'.$uploader->upload_session.'_postdata';
$monitor_file = $uploader->temp_dir .'/'.$uploader->upload_session.'_flength';
$progress_file= $uploader->temp_dir .'/'.$uploader->upload_session.'_progress';
$signal_file  = $uploader->temp_dir .'/'.$uploader->upload_session.'_signal';

##
# Get values assigned for current time and upload start time
##
$dtnow=time();
$dtstart = intval($_GET['dtstart'])>0 ? intval($_GET['dtstart']) : $dtnow;

##
# The values for iStatus are
#	0 - in progress
#	1 - New upload
#	2 - Complete
##

header('Expires: Mon, 26 Jul 1997 05:00:00 GMT');
header("Last-Modified: " . gmdate("D, d M Y H:i:s") . " GMT");
header('Cache-Control: no-store, no-cache, must-revalidate');
header('Cache-Control: post-check=0, pre-check=0', FALSE);
header('Pragma: no-cache');

if($status == 1)
{
	#new upload starting
	show_starting();
}
elseif($status ==0)
{
	##
	# in progress
	# we will try to read in the total size of data to be transfered from the
	# shared file. It will also tell us how much data has been transfered upto
	# now.
	##
    $bRead = readUploadSize($iNums);
    $iRead   = $bRead;
    
    calculateProgress($iTotal,$iRead,$dtstart);

 	make_progress_bar();
	exit;
}
else
{
	show_complete();
}


function readFlength()
{
global $monitor_file;

	if(file_exists($monitor_file))
	{
        $lines  = @file($monitor_file);
		$iTotal = $lines[0];
		return $iTotal;
	}
	return 0;

}
function readUploadSize($nums=0)
{
global $progress_file,$lastRead;
    clearstatcache();
    if(file_exists($progress_file))
	{
        $lines  = @file($progress_file);
		$iRead = $lines[0];
        return $lastRead<$iRead ? $iRead : $lastRead;
	}
	return 0;

    $total =0;
    if($nums==0) $total = @filesize($data_file);

    for($i=1;$i<=$nums;$i++)
	//if(file_exists($data_file.$i))
	{
        clearstatcache();
        $total += @filesize($data_file.$i);
	}
	return $total;

}

#
# Since the progress bar is in html, so it needs to refresh itself periodicaly to
# obtain new values. The refresh url with the query string is generated by this
# function.

function make_url()
{
global $iRead,$iTotal,$iMode,$status,$sessionid,$dtnow,$dtstart;
    $parts=array(
    'iTotal='.$iTotal,
    'iRead='.$iRead,
    'iStatus='.$status,
    'iMode='.$iMode,
    'dtnow='.$dtnow,
    'dtstart='.$dtstart,
    'sessionid='.$sessionid,
    );
	return implode('&',$parts);

}

function show_starting()
{
global $status,$iTotal,$iRead,$dtstart,$signal_file;

	if(($iTotal = readFlength()) > 0 || @file_exists($signal_file))
	{
		$status=0;
        $iRead = readUploadSize($iNums);
        
        calculateProgress($iTotal,$iRead,$dtstart);
	}

	$url = make_url();

    if($status==0)
    make_progress_bar();
    else
    echo trim("start,$url");
}

function show_complete()
{
global $status,$iRead,$iTotal,$bSpeedf,$dtelapsed,$dtelapsedf;

	$status=2;
	$url = make_url();

    $iRead = $iTotal;

    # make the the avergae speed!
    if ($bSpeedf == 0) # avoid divide by zero errors
    {
	    $bSpeed = @($iRead / $dtelapsed); # Bytes uploaded / Seconds elapsed = Bytes/Second speed
	    $bitSpeed = $bSpeed * 8; # bps
	    $kbitSpeed = $bitSpeed / 1000; # Kbps
        $bSpeedf = sprintf("%d",$kbitSpeed); # remove decimals
    }

    echo trim("$iRead,$iTotal,00:00:00,$dtelapsedf,$bSpeedf,100,");
}

function make_progress_bar()
{
global $iRead,$iTotal,$dtRemainingf,$dtelapsedf,$bSpeedf,$percent;

	$url = make_url();

    echo trim("$iRead,$iTotal,$dtRemainingf,$dtelapsedf,$bSpeedf,$percent,$url");
}
function calculateProgress($iTotal,$iRead,$dtstart)
{
global $status,$dtRemainingf,$dtelapsedf,$bSpeedf,$percent;
global $monitor_file,$data_file,$signal_file;

    ##
    # Elapsed time
    # Calculate elapsed time and format for display
    ##
    $dtnow=time();
    $dtelapsed = $dtnow - $dtstart;
    $dtelapsed_sec = ($dtelapsed % 60); # gets number of seconds
    $dtelapsed_min = ((($dtelapsed - $dtelapsed_sec) % 3600) / 60); # gets number of minutes
    $dtelapsed_hours = (((($dtelapsed - $dtelapsed_sec) - ($dtelapsed_min * 60)) % 86400) / 3600);
    # gets number of hours; assuming that we won't be going into days!
    if ($dtelapsed_sec < 10) { $dtelapsed_sec = "0$dtelapsed_sec"; } # append leading zero
    if ($dtelapsed_min < 10) { $dtelapsed_min = "0$dtelapsed_min"; } # append leading zero
    if ($dtelapsed_hours < 10) { $dtelapsed_hours = "0$dtelapsed_hours"; } # append leading zero
    $dtelapsedf = "$dtelapsed_hours:$dtelapsed_min:$dtelapsed_sec"; # display as 00:00:00

    ##
    # Upload speed
    ##
    $bSpeed = 0; # if not yet determined
    if ($dtelapsed > 0) # avoid divide by zero errors
    {
    	$bSpeed = $iRead / $dtelapsed; # Bytes uploaded / Seconds elapsed = Bytes/Second speed
    	$bitSpeed = $bSpeed * 8; # bps
    	$kbitSpeed = $bitSpeed / 1000; # Kbps
    }
    else
    {
    	$kbitSpeed = $bSpeed; # just pass the zero value
    }
    $bSpeedf = sprintf("%d",$kbitSpeed); # remove decimals


    ##
    # Est remaining time
    # Calculate remaining time based on upload speed so far
    ##

    $bRemaining = $iTotal - $iRead; # Total size - amount uploaded = amount remaining
    $dtRemaining = 0;
    if ($bSpeed > 0) {
    	# Bytes remaining / Bytes/Second = Seconds
    	$dtRemaining = $bRemaining / $bSpeed;
    }
    $dtRemaining = sprintf("%d",$dtRemaining); # remove decimals
    $dtRemaining_sec = ($dtRemaining % 60); # gets number of seconds
    $dtRemaining_min = ((($dtRemaining - $dtRemaining_sec) % 3600) / 60); # gets number of minutes
    $dtRemaining_hours = (((($dtRemaining - $dtRemaining_sec) - ($dtRemaining_min * 60)) % 86400) / 3600); # gets number of hours; assuming that we won't be going into days!
    if ($dtRemaining_sec < 10)
    {
     	# append leading zero
    	$dtRemaining_sec = "0$dtRemaining_sec";
    }
    if ($dtRemaining_min < 10)
    {
    	# append leading zero
    	$dtRemaining_min = "0$dtRemaining_min";
    }
    if ($dtRemaining_hours < 10)
    {
     	# append leading zero
    	$dtRemaining_hours = "0$dtRemaining_hours";
    }
    $dtRemainingf = "$dtRemaining_hours:$dtRemaining_min:$dtRemaining_sec"; # display as 00:00:00
    $percent = @($iRead * 100 / $iTotal);
    $percent = sprintf("%d",$percent ); # remove decimals
    
    #
	# division results in truncation errors at times so don't compare percentage
	# There have been occaisional reports of the progress bar showing 100% but not
	# disappearing even after file upload has been completed.
	#
	# Nils Menrad came up with the solution which is to modify the end of upload
	# test.
	#
    if($status ==0)
	if((($iTotal == $iRead) && $iRead != 0)
        || $iRead>$iTotal
        || file_exists($signal_file))
	{
  		show_complete();
        @unlink($progress_file);
        @unlink($monitor_file);
        @unlink($data_file);
        @unlink($signal_file);

        exit;
    }
}
?>
